Принципы:
 
EDITOR=nano crontab -e
 
export http_proxy=http://ya.ru:3128 - объявляем глобальную переменную
wget http://что_то_скачать - пытаемся воспользоваться wget
 
 
Показать переменные:
set - показывает все переменные окружения
env - показывает переменные помеченные как экспортируемые
 
Можно увидеть в настройках:
login, sshd, telnetd,  ~/.profile,  ~/.cshrc и в других файлах.
Переменные: HOME, SHELL, PATH, TERM. LOGNAME, USER, EDITOR, ENV и т.д.



Примеры \ присвоения переменной:
0. Переменную распознает программа  
1. Переменную распознает шелл
 
Пример как присваивается переменная:
a=HEllo
set | grep '^a'
 
export a
env | grep '^a'
 
dir=/bin
ls -l $dir
 
echo $a
 
a=pwd
$a
 
Примеры с кавычками:
Различие между кавычками
В одинарных кавычках содержимое выводится как есть.
В двойных кавычках переменные исполняются.
 
a='Hello World'
echo $a
 
a="Hello World"
echo $a
 
Обходимся без кавычек, экранирование пробела с помощь слеша:
a=Hello\ World
echo $a
 
Примеры подстановки переменной:
a="Hello"
b=$a
echo $b
 
Пример с подстановкой переменно и работы одинарной кавычки
Одинарные кавычки всегда передают значение как есть, то есть шелл проигнорирует переменную.
b='$a World'
echo $b
 
Пример а если мы всё-таки хотим передать переменную:
На помощь приходят двойные кавычки:
b="$a World"
echo $b
 
Экранирование(слеш):
Слеш отменяет действие многих спец символов.
b=$a\ world
echo $b
 
b=\$a\ World
echo $b
 
b=$aWorld
echo $b
 
b=${a}World
echo $a
echo $b
 
Значения переменных рекомендуется брать в фигурные скобки.
b=${a}World
echo $a
echo $b




Арифметика
!! шелл оперирует переменными окружениями
!!! Арифметики не будет при таких записях:
a=3+6
echo $a
 
a=222
b=333
 
c=${a}${b}
echo $c
 
c=${a}+${b}
echo $c
 
!!! Арифметике быть!
Для арифметических действий используется конструкция из скобок $(( выражение ))
a=$((3+6))
a=$(($a*6))
 
А если сделать вот так:
c=((${a}+${b}))
c=$((${a}+${b}))
echo $c
 
Программа для арифметики expr:
a=1
a=$(expr $a + 1)
echo $a





Применение переменных с программами:
` - обратный апостроф ( не путать с одинарной кавычкой)
` - служит для выполнения команды
 
`команда` - выполнится команда внутри апострофов
$(команда) - ведет себя аналогично при использовании обратного апострофа (`)
 
dir='pwd'
echo $dir
 
d=$(date)
echo $d
 
x=`date '+%Y.%m.%d'`
echo $x
 
z=$(date '+%Y.%m.%d')
echo $z
 
c=`ps -uaxf | grep sshd |grep -v grep`
echo $c
 
 
сгенерировать случайное число
rnd=`jot -r 1 1 10`
 
Сгенерировать число от 1 до 10 
gen10=`seq 10`
echo $gen10
 
filecount=`ls/bin | wc -l`
echo $filecount




Ввод пользователя
Программа read, ожидает ввода пользователя и сохраняет в переменную
read a
echo $a
 
Пример использования:
echo -n "Enter Name: "; read a; echo Hello "$a"




Подстановки в файл:
Речь идет о спец символах * ? и т.д.
echo /bin/c* - покажет все файлы начинающиеся на c
cat - можно редактировать и смотреть файлы (при использовании <>)
file - команда позволяет определить тип файла, что бы случайно не открыть бинарный файл



Чтение переменных с исключением
0. Пример исключаем суффикс sample при выводе переменной i
i=sip.conf.sample
 
echo $i
echo ${i}
echo ${i%.sample}
 
1. Пример исключить (GET /) при выводе переменной i
i='GET /index.html'
echo ${i#GET /}




Удаление переменной
unset CLICOLOR
unset EDITOR
unset http_proxy



Объединение команд (;)
echo -n "Enter Name: "; read a; echo Hello "$a"
sleep 3; echo -e "\007"



Последовательные команды в текстовом файле
Пример файла:
vim 1.txt
---------
echo -n "Enter Name: "
read p
echo Hello "$p"
---------
 
Пример выполнения 1:
sh 1.txt - запасаем новый шелл и выполняем файл 1.txt
 
Пример выполнения 2:
. 1.txt - точка говорит выполнить в текущем контексте шелла файл 1.txt



Последовательные команды в выполняемом файле
Пример файла f2.sh:
-------------
#!/bin/sh
echo -n "Enter Name: "
read p
echo Hello "$p !!!"
-------------
 
Выполнение:
chmod u+x f2.sh - даем права на выполнения файла
 
f2.sh - выполняем файл при условии если он расположен в PATH
 
/home/user/f2.sh
./f2.sh
 
 
sh f2.sh
. f2.sh



Специальные символы
$? - коды возврата
 
[ - это программа сравнения, и если выполнить (which [) мы увидим что программа называется test и она возвращает 1 или 0, код возврата можно увидеть по echo $?
man [
test 6 -lt 3
echo $?
 
 
$1 - аргумент запуска программы 
$2 - аргумент запуска программы
$3  - аргумент запуска программы
 
Пример работы:
agr.sh - создаем скрипт
--------------
echo $2 $3 $1
--------------
 
Ну и проверяем: 
. agr.sh aaa bbb ccc
 
&& - если программа этого символом && выполнилась успешно выполняй следующую после этого символа &&
 
 
#  - комментарий
 
 
Операторы равенства:
eq  равно (=) (Equals)
ne  не равно (!=) (Not equal)
 
Операторы диапазона:
gt больше (>) (Greater than)
lt меньше (<) (Less than)
ge больше или равно (=>) (Equal or greater than)
le меньше или равно (=<) (Equal or less than)
 
 
Во многих языках программирования двоеточие (:) означает истина (True) и возвращает 0
 
Задать символ разделитель с помощью IFS
IFS=:





Чтение из файлов, парсинг файлов, while, for:
Пример использования IFS, перенаправления в read
------------------------
#!/bin/sh
IFS=:
while read a b c d e f g
do 
   echo "$a $g"
done < /etc/passwd
------------------------
 
 
 
Пример с использованием for
------------------------
#!/bin/sh
for i in `cut -d: -f1 /etc/passwd`
do
  echo user $i
done
------------------------



